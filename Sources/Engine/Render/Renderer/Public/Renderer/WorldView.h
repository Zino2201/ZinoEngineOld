#pragma once

#include "EngineCore.h"
#include "Maths/Matrix.h"
#include "Render/RenderSystem/RenderSystemResources.h"
#include "RenderPass/RenderPass.h"
#include "Mesh.h"
#include "RenderPass/RenderPassRenderer.h"
#include "Render/UniformBuffer.h"
#include <robin_hood.h>

namespace ZE::Renderer
{

class CWorldProxy;
class CRenderableComponentProxy;

/**
 * A view to a world
 */
struct SWorldView
{	
	CWorldProxy& WorldProxy;

	/** Viewport info */
	Math::SRect2D Scissor;
	SViewport Viewport;

	/** Camera infos */
	Math::SVector3 ViewPos;
	Math::SVector3 ViewForward;
	Math::SMatrix4 ViewProj;

	/** Where to render ? */
	CRSTexture* TargetRT;

	/** INTERNAL STATE */
	struct alignas(16) SWorldViewUBO
	{
		glm::mat4 ViewProj;
		Math::SVector3Float ViewPos;
		Math::SVector3Float ViewForward;
	};
	TUniformBuffer<SWorldViewUBO> TEST_ViewUBO;

	/** Visible cached drawcalls per pass */
	robin_hood::unordered_map<ERenderPassFlagBits, std::vector<size_t>> VisibleCachedDrawcalls;

	/** Visible meshes generated by dynamic proxies */
	std::vector<SMesh> VisibleDynamicMeshes;
	std::vector<ERenderPassFlags> VisibleDynamicMeshRenderPassFlags;
	std::vector<const CRenderableComponentProxy*> VisibleDynamicMeshProxies;
	
	/** Render pass renderer for this view per pass */
	robin_hood::unordered_map<ERenderPassFlagBits, CRenderPassRenderer> RenderPassRendererMap;

	SWorldView(CWorldProxy& InWorldProxy) : WorldProxy(InWorldProxy) 
	{
		VisibleCachedDrawcalls.reserve(static_cast<size_t>(ERenderPassFlagBits::Count));
		RenderPassRendererMap.reserve(static_cast<size_t>(ERenderPassFlagBits::Count));
	}
};

}