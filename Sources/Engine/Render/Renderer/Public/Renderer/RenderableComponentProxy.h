#pragma once

#include "EngineCore.h"
#include "Render/RenderThreadResource.h"
#include "Render/UniformBuffer.h"
#include "MeshRenderPass.h"
#include <unordered_set>

namespace ZE::Renderer
{

class CWorldProxy;
class CMaterialProxy;
class CProxyDrawCommand;

/**
 * Per-instance data of a renderable component
 */
struct SRenderableComponentPerInstanceData
{
    alignas(16) glm::mat4 World;
};

/**
 * Static data about a single proxy
 */
struct SStaticProxyData
{
    CMaterialProxy* Material;
    CRSBufferPtr VertexBuffer;
    CRSBufferPtr IndexBuffer;
    uint32_t IndexCount;
    EIndexFormat IndexFormat;
    EMeshRenderPass RenderPassFlags;
};

/**
 * Cache mode of a renderable component proxy
 * Defines if draw commands will be cached for this proxy
 */
enum class ERenderableComponentProxyCacheMode
{
    Cachable,
    Dynamic
};

/**
 * Render-thread version of a rendereable component
 * Class should be derived by rendereable components
 */
class RENDERER_API CRenderableComponentProxy : public CRenderThreadResource
{
    friend class CWorldProxy;
    friend class CMeshRenderPass;

public:
    struct SCollectionInfos
    {
        size_t CollectionIndex;
        size_t InstanceIndex;

        SCollectionInfos() : CollectionIndex(0), InstanceIndex(0) {}
        SCollectionInfos(const size_t& InCollectionIndex,
            const size_t& InInstanceIndex) : CollectionIndex(InCollectionIndex), 
            InstanceIndex(InInstanceIndex) {}
    };

    CRenderableComponentProxy(CWorldProxy* InWorld, 
        ERenderableComponentProxyCacheMode InCacheMode);
    virtual ~CRenderableComponentProxy();

    void InitResource_RenderThread() override;
    void DestroyResource_RenderThread() override;

    void BuildDrawCommands();

    virtual std::vector<SStaticProxyData> GetStaticProxyData() const { return {}; }
    virtual void DrawDynamic() const {}

    void SetTransform(const Math::STransform& InTransform) { Transform = InTransform; }

    ERenderableComponentProxyCacheMode GetCacheMode() const { return CacheMode; }
private:
    void CopyTransformToUBO();
private:
    CWorldProxy* World;

    /** The transform of the component's entity */
    Math::STransform Transform;

    /** Cached per instance data, only updated when game thread version is modified */
    SRenderableComponentPerInstanceData PerInstanceData;

    TUniformBuffer<SRenderableComponentPerInstanceData> PerInstanceDataUBO;

    ERenderableComponentProxyCacheMode CacheMode;

    /** Collections infos */
    std::vector<SCollectionInfos> CollectionsIndices;

    /** Draw commands generated by this proxy, used to delete later commands */
    std::unordered_map<EMeshRenderPass, std::unordered_set<CProxyDrawCommand*>> DrawCommands;
};

}