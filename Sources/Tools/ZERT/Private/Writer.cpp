#include "Writer.h"
#include "Header.h"
#include <fstream>
#include <string>
#include <iostream>

uint64_t unique_header_id = 0;

Writer::Writer(const Header& in_header, const std::filesystem::path& in_out_dir) 
	: header(in_header), out_dir(in_out_dir)
{
	write_h();
	write_cpp();

	unique_header_id++;
}

void Writer::write_h()
{
	/**
	 * Create directory if it doesn't exist
	 */
	if(!std::filesystem::exists(out_dir))
		std::filesystem::create_directories(out_dir);

	std::filesystem::path out_file = out_dir;

	std::filesystem::path filename(header.path.stem());
	out_file /= filename.string() + ".gen.h";

	std::string unique_id = header.module_name + "_" + std::to_string(unique_header_id); 

	std::ofstream file(out_file.c_str(), std::ios::out);
	file << "#pragma once\n\n";
	file << "/** GENERATED BY ZERT. DO NOT MODIFY! */";
	file << "\n\n";
	file << "#include \"Reflection/Macros.h\"\n";
	file << "#undef ZE_CURRENT_FILE_UNIQUE_ID\n";
	file << "#define ZE_CURRENT_FILE_UNIQUE_ID " << unique_id << "\n\n";

	for(const auto& cl : header.classes)
	{
		/** Forward declaration */
		if(cl.is_struct())
			file << "namespace " << cl.znamespace << " { struct " << cl.name << "; }\n";
		else
			file << "namespace " << cl.znamespace << " { class " << cl.name << "; }\n";

		file << "ZE_REFL_DECLARE_CLASS(" << cl.znamespace << "::" << cl.name << ");\n";

		if(cl.is_struct())
			file << "#define ZE_Refl_Body_" << unique_id << "_" << cl.get_body_line() 
			<< " ZE_REFL_DECLARE_STRUCT_BODY(" << cl.znamespace << "::" << cl.name << ");\n\n";
		else
			file << "#define ZE_Refl_Body_" << unique_id << "_" << cl.get_body_line() 
				<< " ZE_REFL_DECLARE_CLASS_BODY(" << cl.znamespace << "::" << cl.name << ");\n\n";
	}

	for(const auto& en : header.enums)
	{
		file << "namespace " << en.znamespace << " { enum class " << en.name << "; }\n";
		file << "ZE_REFL_DECLARE_ENUM(" << en.znamespace << "::" << en.name << ")\n\n";
	}

	file.close();
}

void Writer::write_cpp()
{
	std::filesystem::path out_file = out_dir;

	std::filesystem::path filename(header.path.stem());
	out_file /= filename.string() + ".gen.cpp";

	std::string unique_id = header.module_name + "_" + std::to_string(unique_header_id); 

	std::ofstream file(out_file.c_str(), std::ios::out);
	file << "/** GENERATED BY ZERT. DO NOT MODIFY! */\n\n";
	file << "#include " << header.path << "\n";
	file << "#include \"Reflection/Builders.h\"\n";
	file << "#include \"Reflection/Class.h\"\n";
	file << "#include \"Reflection/Enum.h\"\n";
	file << "#include \"Reflection/Serialization.h\"\n\n";

	/** Serialization */
	for(const auto& cl : header.classes)
		file << "ZE_REFL_SERL_REGISTER_TYPE(" << cl.znamespace << "::" << cl.name << ", " << cl.name << ");\n\n";
	
	file << "namespace ze::reflection\n{\n";
	file << "ZE_REFL_BUILDER_FUNC(" << unique_id << "_" << header.path.stem().string() << ")\n{\n"; 
	file << "using namespace ze;\n";

	for(const auto& cl : header.classes)
	{
		file << "{\n";
		file << "using namespace " << cl.znamespace << ";\n";
		std::string builder_var = "Builder_" + cl.name;

		file << "builders::ClassBuilder<" << cl.znamespace << "::" << cl.name << "> " << builder_var << ";\n";
		
		for(const auto& ctor : cl.get_ctors())
			file << builder_var << ".constructor<" + ctor + ">();\n";

		if(cl.get_ctors().empty())
			file << builder_var << ".constructor<>();\n";

		for(const auto& parent : cl.get_parents())
			file << builder_var << ".parent<" << parent << ">();\n";

		for(const auto& property : cl.get_properties())
		{
			file << builder_var << ".property<" << property.type << ">(\"" 
				+ property.name + "\", &" << cl.znamespace << "::" << cl.name << "::" << property.name << ", ";
			file << "{\n";
			for(const auto& [key, value] : property.metadatas)
			{   
				std::string keyv = key;
				std::string valuev = value;

				keyv.erase(std::remove_if(keyv.begin(), keyv.end(), isspace), keyv.end());
				valuev.erase(std::remove_if(valuev.begin(), valuev.end(), isspace), valuev.end());

				file << "{ \"" << keyv << "\", \"" << valuev << "\" },";
			}
			file << "}";
			file << ");\n";
		}

		file << "}\n";
	}

	for(const auto& en : header.enums)
	{
		file << "{\n";
		file << "using namespace " << en.znamespace << ";\n";
		std::string builder_var = "Builder_" + en.name;

		file << "builders::EnumBuilder<" << en.znamespace << "::" << en.name << "> " << builder_var << ";\n";
		
		for(const auto& value : en.values)
			file << builder_var << ".value(\"" << value << "\", " << en.name << "::" << value << ");\n";
	
		file << "}\n";
	}

	file << "}\n}";
	
	file.close();
}