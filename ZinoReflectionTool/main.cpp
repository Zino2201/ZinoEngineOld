/**
 * Tool used to generate reflection data for ZinoEngine (RTTR)
 * (very shitty, need to be remade one day)
 */

#include <iostream>
#include <filesystem>
#include <array>
#include <string>
#include <sstream>
#include <fstream>
#include <chrono>

namespace fs = std::filesystem;

enum class EEncounterType
{
	None,
	Class,
	Property
};

const std::string g_Header = "/** Reflection data generated by ZinoReflectionTool, don't modify! */\n\n#include \"Core/EngineCore.h\"\n";
const std::string g_RTTRBegin = "RTTR_REGISTRATION\n{";
const std::string g_RTTREnd = "}";
const std::string g_Tab = "	";

/**
 * A ZinoEngine property
 */
class CZProperty
{
public:
	CZProperty(const std::string& InName) : Name(InName) {}
public:
	std::string Name;
};

/**
 * A ZinoEngine class
 */
class CZClass
{
public:
	CZClass(const std::string& InName) : Name(InName) {}
public:
	std::string Name;
	std::vector<CZProperty> Properties;
};

struct SHeader
{
	std::string IncludePath;
	std::vector<CZClass> Classes;
	bool bHasReflectionData;
};

/** Utils functions */
namespace RTTRGen
{
	std::string RegisterClass(const std::string& InName)
	{
		std::stringstream ss;
		ss << "rttr::registration::class_<" << InName << ">(\"" << InName << "\")";
		return ss.str();
	}

	std::string RegisterProperty(const std::string& InClassName, const std::string& InName)
	{
		std::stringstream ss;
		ss << ".property(\"" << InName << "\", &" << InClassName << "::" << InName << ")";
		return ss.str();
	}
}

/**
 * Parse a header
 */
SHeader ParseHeader(std::ofstream& Output, fs::path InPath)
{
	SHeader Header;

	/** Parse current file */
	std::ifstream File(InPath.generic_string());

	if (File.is_open()) 
	{
		/** List of classes, enums, structures, */
		std::vector<CZClass> Classes;

		CZClass* CurrentClass = nullptr;

		std::string Line;
		EEncounterType WaitingEncounter = EEncounterType::None;
		while (getline(File, Line)) 
		{
			if(WaitingEncounter == EEncounterType::Class && Line.rfind("class", 0) == 0)
			{
				std::string ClassNameWithParents = Line.substr(Line.find("class") + 6);
				std::string ClassName = ClassNameWithParents.substr(0, ClassNameWithParents.find(":", 0) - 1);

				Classes.emplace_back(ClassName);
				CurrentClass = &Classes.back();
				WaitingEncounter = EEncounterType::None;
			}
			else if(Line.rfind("ZCLASS", 0) == 0)
			{
				WaitingEncounter = EEncounterType::Class;
			}
			else if(Line.rfind("	ZPROPERTY", 0) == 0)
			{
				WaitingEncounter = EEncounterType::Property;
			}
			else if (WaitingEncounter == EEncounterType::Property)
			{
				std::string PropName = Line.substr(Line.find(" ") + 1);
				PropName.erase(std::remove(PropName.begin(), PropName.end(), ';'), PropName.end());
				CurrentClass->Properties.emplace_back(PropName);
				WaitingEncounter = EEncounterType::None;
			}
		}

		File.close();

		Header.IncludePath = InPath.relative_path().generic_string();
		Header.Classes = Classes;
		Header.bHasReflectionData = !Classes.empty();
	}

	return Header;
}

int main()
{
	std::cout << "ZinoReflectionTool now generating reflection data" << std::endl;
	std::cout << "Working directory : " << std::filesystem::current_path().generic_string() << std::endl;

	auto Start = std::chrono::high_resolution_clock::now(); 

    /**
	 * Scan all .h files
	 */
	std::vector<fs::path> Paths;
	for (auto& Path : fs::recursive_directory_iterator("./"))
	{
		if (Path.path().extension() == ".h")
			Paths.push_back(Path.path());
	}

	std::ofstream Output("ReflectionData.cpp", std::ios::ate);

	/**
	 * Parse and generate reflection data for each header
	 */
	std::vector<SHeader> Headers;
	for(auto& Path : Paths)
		Headers.push_back(ParseHeader(Output, Path));

	Output << g_Header;

	/** First write includes */
	for (const auto& Header : Headers)
	{
		if(Header.bHasReflectionData)
			Output << "#include \""<< Header.IncludePath << "\"" << std::endl;
	}

	Output << std::endl << g_RTTRBegin << std::endl;

	/** Write data now */
	for(const auto& Header : Headers)
	{
		if(Header.bHasReflectionData)
		{
			for (const CZClass& Class : Header.Classes)
			{
				Output << g_Tab << RTTRGen::RegisterClass(Class.Name);
				for (const CZProperty& Property : Class.Properties)
				{
					Output << std::endl << g_Tab << g_Tab << RTTRGen::RegisterProperty(Class.Name,
						Property.Name);
				}

				Output << ";" << std::endl;
			}
		}
	}

	Output << g_RTTREnd << std::endl;

	Output.close();

	auto End = std::chrono::high_resolution_clock::now(); 
	auto Duration = std::chrono::duration_cast<std::chrono::milliseconds>(End - Start); 

	std::cout << "Reflection data generated in " << Duration.count() << " ms";

	return 0;
}